[{"content":"Introduction Neetcode 150 is a popular set of Leetcode problems designed to help programmers prepare for coding interviews. I\u0026rsquo;ve decided to document my thought process while solving these problems, hoping they might help some of my readers.\nNote: This post won\u0026#39;t cover all the questions from Neetcode 150. Instead, I\u0026#39;ll focus on the ones I found particularly tricky / challenging. I trust in your ability to know basic logic behind each topic. Sliding window Key factor: The use of unordered_map / array Use l and r, which l stays [only change when certain condition met], r keep moving Compare array for char 26 Keep each index / count in map 424.Longest Repeating Character Replacement The key for Longest Repeating is to count the appearance of each letter in current window That leads us to know the maxCurrent in the window To make sure the window is valid, the replacement is not over k (current length - maxCurrent \u0026lt;= k). If not, move i â†’ decrement vector[i] by 1 Two ways to do:\nvector count to keep track of numbers appearance in current window, we know the string only contains uppercase, vector\u0026lt;int\u0026gt; 26 fit\nFind the max appearance in the current window, to do so, have a function check through the vector to find the maxCurrent everytime To make sure the window is valid, the replacement is not over k (current length - maxCurrent \u0026lt;= k). If not, move i, decrement vector[i] by 1 Update Longest Have maxf only update when a greater num appears.\nreplace if statement by (j - i + 1 - maxf \u0026gt; k) class Solution { public: int findMax(const vector\u0026lt;int\u0026gt;\u0026amp; nums){ int longest = 0; for(const int\u0026amp; num : nums){ longest = max(num, longest); } return longest; } int characterReplacement(string s, int k) { vector\u0026lt;int\u0026gt; m (26, 0); int i = 0; int longest = 0; int maxf = 0; for(int j = 0; j \u0026lt; s.length(); ++j){ m[s[j] - \u0026#39;A\u0026#39;]++; maxf = max(maxf, m[s[j] - \u0026#39;A\u0026#39;]); while(i \u0026lt; s.length() \u0026amp;\u0026amp; j - i + 1 - maxf \u0026gt; k){ m[s[i] - \u0026#39;A\u0026#39;]--; i++; } longest = max(j - i + 1, longest); } return longest; } }; 425. Minimum Window Substring Mininum Window: Have two maps check currentWindow size, same thing as sliding window. The key is to Have a â€œformâ€ to check if the window is valid (form == 0), once valid, start moving it until the form != 0. Have an arr[2] = {length, starting} to update the answer. Step:\nCreate two maps (dict, currentWindow), store target string into dict Create arr for answer, â€œformâ€ and i Increment in currentWindow, if (dict also contain the letter and two numbers are the same), decrease â€œformâ€; While form == 0, update arr and remove s[i] from currentWindow. Same as step 3 if dict has it and dict[i] \u0026gt; currentWindow[i], increase the form. (Means the letter in currentWindow is less than / not in requirement) Return arr, or â€œâ€ class Solution { public: string minWindow(string s, string t) { unordered_map\u0026lt;char, int\u0026gt; dict; unordered_map\u0026lt;char, int\u0026gt; currentWindow; for(const char\u0026amp; c : t){ dict[c]++; } int i = 0; int form = dict.size(); int arr [] = {-1, 0}; for(int j = 0; j \u0026lt; s.length(); ++j){ currentWindow[s[j]]++; if(dict.count(s[j]) \u0026amp;\u0026amp; dict[s[j]] == currentWindow[s[j]]){ form--; } while(i \u0026lt;= j \u0026amp;\u0026amp; form == 0){ if(arr[0] == -1 || j - i + 1 \u0026lt; arr[0]){ arr[0] = j - i + 1; arr[1] = i; } currentWindow[s[i]]--; if(dict.count(s[i]) \u0026amp;\u0026amp; dict[s[i]] \u0026gt; currentWindow[s[i]]){ ++form; } ++i; } } return arr[0] == -1? \u0026#34;\u0026#34; : s.substr(arr[1], arr[0]); } }; 426. Sliding Window Maximum The key for Sliding Window Maximum is if a num is maxCurrent, we donâ€™t need any number before it. And if the incoming number is greater than deque back, we can smash it Step:\nCreate a deque to store index If deque not empty and incoming is greater, smash anything is smaller Check if dq front is out of bound (i \u0026gt; dq.front()) if(j + 1 \u0026gt;= k) push_back result and move the i. (The if statement checks if j+1 \u0026lt; k, which we havenâ€™t insert enough elements to meet the window size, j is index, ex. If k = 3, j at least should be 2 in index) class Solution { public: vector\u0026lt;int\u0026gt; maxSlidingWindow(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { deque\u0026lt;int\u0026gt; sta; // store index int i = 0; vector\u0026lt;int\u0026gt; answer; for(int j = 0; j \u0026lt; nums.size(); ++j){ while(!sta.empty() \u0026amp;\u0026amp; nums[sta.back()] \u0026lt;= nums[j]){ sta.pop_back(); } sta.push_back(j); if(sta.front() \u0026lt; i){ sta.pop_front(); } if(j - i + 1 \u0026gt;= k){ answer.push_back(nums[sta.front()]); ++i; } } return answer; } }; Stack 155. Min Stack The key of Min Stack is to use two stacks: nums and min_stack. The nums stack stores all the values, while the min_stack only stores the current minimum values and updates when a new value is less than or equal to the top of the stack.\nYou might wonder, \u0026ldquo;What about when the incoming value is greater than the top of the stack? Shouldn\u0026rsquo;t it be stored in min_stack too?\u0026rdquo; The answer is no. You might think that if a larger value should be stored somewhere at the bottom of min_stack so that when all the smaller numbers are popped, this larger value will be needed. But that\u0026rsquo;s not true. When pop() is called, larger numbers will be popped before smaller ones, so there\u0026rsquo;s no need to store them in min_stack.\nThere are two approaches to solving this:\nCreate nums and min_stack.\nFor Push(): push the value into nums and push into min_stack only if the condition is met.\nFor Pop(): pop from min_stack only if nums.top() == min_stack.top().\nConsider a scenario where the input is something like // 2 2 2 2 2. We donâ€™t want to store all these values in the stack. Instead, create a pair\u0026lt;int, appearance\u0026gt; to keep track of the numbers and their frequencies.\nclass MinStack { public: //2 2 2 2 2 2 2 // {2, 7} stack\u0026lt;int\u0026gt; nums; stack\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; min_stack; MinStack() { } void push(int val) { nums.push(val); if(min_stack.empty() || val \u0026lt; min_stack.top().first){ min_stack.push({val, 1}); }else if(val == min_stack.top().first){ min_stack.top().second++; } } void pop() { if(!min_stack.empty() \u0026amp;\u0026amp; min_stack.top().first == nums.top()){ min_stack.top().second--; if(min_stack.top().second == 0){ min_stack.pop(); } } nums.pop(); } int top() { return nums.top(); } int getMin() { return min_stack.top().first; } }; 150. Evaluate Reverse Polish Notation Polish Notation should be straightforward, the key is pushed back to stack every time the calculation is done! Step:\nCreate a stack\nCheck if val is digit, if so, push to stack and continue; If(token.size() \u0026gt; 1 || isdigit(token[0])) If we skip step 2, then val is an operator. Perform the operator and store it back to stack. Eventually the stack will have only one num (the answer), return stack.top() class Solution { public: bool isoper(string s){ return s.length() == 1 \u0026amp;\u0026amp; (s == \u0026#34;+\u0026#34; || s== \u0026#34;-\u0026#34; || s== \u0026#34;*\u0026#34; || s== \u0026#34;/\u0026#34;); } int calculator(int num1, int num2, char op){ switch(op){ case \u0026#39;+\u0026#39;: return num1 + num2; case \u0026#39;-\u0026#39;: return num1 - num2; case \u0026#39;*\u0026#39;: return num1 * num2; case \u0026#39;/\u0026#39;: return num1 / num2; } return 0; } int evalRPN(vector\u0026lt;string\u0026gt;\u0026amp; tokens) { if(tokens.size() == 1){ return stoi(tokens[0]); } stack\u0026lt;int\u0026gt; sta; int answer = 0; for(int i = 0; i \u0026lt; tokens.size(); ++i){ if(!isoper(tokens[i])){ sta.push(stoi(tokens[i])); }else{ int num2 = sta.top(); sta.pop(); int num1 = sta.top(); sta.pop(); answer = calculator(num1, num2, tokens[i][0]); sta.push(answer); } } return answer; } }; 22. Generate Parentheses For generate parentheses We should know that we need â€œopenâ€ and â€œcloseâ€ to both equal to n to push Whenever open == close, ex: () / (( )) // () (), we could only add an open bracket. Therefore we should visit open bracket first Only adding a close bracket if close \u0026lt; open, means we have extra open to be matched. Step:\nBacktracking, we should create a helper function (vector answer, string temp, int n, int open, int close) If open and close both == n, push into answer If open \u0026lt; n, temp push an open bracket and helper(open + 1), finally remove temp.back If open \u0026gt; close, same thing, but push close bracket. class Solution { public: void helper(vector\u0026lt;string\u0026gt;\u0026amp; answer, string\u0026amp; temp, int n, int open, int close){ if(open == n \u0026amp;\u0026amp; close == n){ answer.push_back(temp); return; } if(open \u0026lt; n){ temp += \u0026#39;(\u0026#39;; helper(answer, temp, n, open + 1, close); temp.pop_back(); } if(open \u0026gt; close){ temp += \u0026#39;)\u0026#39;; helper(answer, temp, n, open, close + 1); temp.pop_back(); } } vector\u0026lt;string\u0026gt; generateParenthesis(int n) { vector\u0026lt;string\u0026gt; answer; string temp = \u0026#34;\u0026#34;; helper(answer, temp, n, 0, 0); return answer; } }; 23. Daily Temperatures For Daily Temperatures, Iâ€™m correct with monolithic stack in the first place and obtained a solution by myself. The key is having a pair {temperature, index} in the stack. And pop only if currentTemp is higher [warmer], else push into stack Step:\nCreate a stack and vector for answer If sta not empty \u0026amp;\u0026amp; currentTemp \u0026gt; sta.top() answer[sta.top().second] = the gap in days pop from stack Else, push into stack class Solution { public: //monolithic stack vector\u0026lt;int\u0026gt; dailyTemperatures(vector\u0026lt;int\u0026gt;\u0026amp; temperatures) { stack\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt; sta; vector\u0026lt;int\u0026gt; answer (temperatures.size()); for(int i = 0; i \u0026lt; temperatures.size(); ++i){ // if(sta.empty() || sta.top().first \u0026gt;= temperatures[i]){ // sta.push({temperatures[i], i}); // continue; // } while(!sta.empty() \u0026amp;\u0026amp; sta.top().first \u0026lt; temperatures[i]){ answer[sta.top().second] = i - sta.top().second; sta.pop(); } sta.push({temperatures[i],i}); } return answer; } }; 24. Car Fleet The key of Car Fleet that we are dealing with the time cars get to the destination based on position and speed. Then if two cars spend the same time getting to the final, they will meet. Or the car behind spends less time (faster) to reach, they will also meet. Step:\nCreate a vector\u0026lt;position, double time\u0026gt; and store all the values Sort the vector based on position Make a fleet counter and maxTime Start from the back where the car is the closest to destination, and if the time it spends is greater than maxTime means the currentTime is not catching the previous carfleet, we should therefore increment the carfleet by one and update maxTime class Solution { public: int carFleet(int target, vector\u0026lt;int\u0026gt;\u0026amp; position, vector\u0026lt;int\u0026gt;\u0026amp; speed) { vector\u0026lt;pair\u0026lt;int, double\u0026gt;\u0026gt; cars(position.size()); //(destination - position[i] / speed[i]) for(int i = 0; i \u0026lt; position.size(); ++i){ double time = (double)(target - position[i]) / speed[i]; cars[i] = {position[i], time}; } sort(cars.begin(), cars.end()); int carFleet = 0; double maxTime = 0.0; for(int i = cars.size() - 1; i \u0026gt;= 0; --i){ double time = cars[i].second; if(time \u0026gt; maxTime){ maxTime = time; carFleet++; } } return carFleet; } }; 84. Largest Rectangle in Histogram The idea for Largest Rectangle is we should know how far a unit can expand, and we should maintain it in the stack before that happens. And until when we reach a smaller height, we reach the end point, then we should pop from the stack and calculate the width (the initial point to expanding end) and height(initial height).\nFor the currentHeight, because we pop from stack until reaching a smaller unit where currentHeight cannot expand, we make that as our initial height for current.\nStep:\nCreate a stack \u0026lt;start, height\u0026gt;, maxArea for answer When stack is not empty and currentHeight is smaller, we pop the stack and update maxArea and start position of currentHeight Then push {start position, currentHeight} to stack After the loop, there are elements left in the stack which means these are heights that can expand till the end. Therefore we should update the maxArea by height * width (width is endpoint - start) class Solution { public: int largestRectangleArea(vector\u0026lt;int\u0026gt;\u0026amp; heights) { stack\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; sta; // \u0026lt;start, height\u0026gt; int maxArea = 0; for(int i = 0; i \u0026lt; heights.size(); ++i){ int start = i; while(!sta.empty() \u0026amp;\u0026amp; heights[i] \u0026lt; sta.top().second){ int width = i - sta.top().first; int height = sta.top().second; maxArea = max(maxArea, height * width); start = sta.top().first; sta.pop(); } sta.push({start,heights[i]}); } int n = heights.size(); while(!sta.empty()){ pair\u0026lt;int, int\u0026gt; p = sta.top(); sta.pop(); maxArea = max(maxArea, p.second * (n - p.first)); } return maxArea; } }; ","permalink":"https://www.ziirui-resume-website.com/posts/tech/leetcode_150/","summary":"Introduction Neetcode 150 is a popular set of Leetcode problems designed to help programmers prepare for coding interviews. I\u0026rsquo;ve decided to document my thought process while solving these problems, hoping they might help some of my readers. Note: This post won\u0026#39;t cover all the questions from Neetcode 150. Instead, I\u0026#39;ll focus on the ones I found particularly tricky / challenging. I trust in your ability to know basic logic behind each topic. Sliding window Key factor: The use of unordered_map / array Use l and r, which l stays [only change when certain condition met], r keep moving Compare array for char 26 Keep each index / count in map 424.Longest Repeating Character Replacement The key for Longest Repeating is to count the appearance of each letter in current window That leads us to know the maxCurrent in the window","title":"Leetcode 150"},{"content":"1. ä»‹ç» scanå‘½ä»¤çš„ä½œç”¨å’Œkeys *çš„ä½œç”¨ç±»ä¼¼ï¼Œä¸»è¦ç”¨äºæŸ¥æ‰¾ redis ä¸­çš„é”®ï¼Œä½†æ˜¯åœ¨æ­£å¼çš„ç”Ÿäº§ç¯å¢ƒä¸­ä¸€èˆ¬ä¸ä¼šç›´æ¥ä½¿ç”¨keys *è¿™ä¸ªå‘½ä»¤ï¼Œå› ä¸ºä»–ä¼šè¿”å›æ‰€æœ‰çš„é”®ï¼Œå¦‚æœé”®çš„æ•°é‡å¾ˆå¤šä¼šå¯¼è‡´æŸ¥è¯¢æ—¶é—´å¾ˆé•¿ï¼Œè¿›è€Œå¯¼è‡´æœåŠ¡å™¨é˜»å¡ï¼Œæ‰€ä»¥éœ€è¦ scan æ¥è¿›è¡Œæ›´ç»†è‡´çš„æŸ¥æ‰¾\nscanæ€»å…±æœ‰è¿™å‡ ç§å‘½ä»¤ï¼šscanã€sscanã€hscanã€zscanï¼Œåˆ†åˆ«ç”¨äºè¿­ä»£æ•°æ®åº“ä¸­çš„ï¼šæ•°æ®åº“ä¸­æ‰€æœ‰é”®ã€é›†åˆé”®ã€å“ˆå¸Œé”®ã€æœ‰åºé›†åˆé”®ï¼Œå‘½ä»¤å…·ä½“ç»“æ„å¦‚ä¸‹ï¼š\nscan cursor [MATCH pattern] [COUNT count] [TYPE type] sscan key cursor [MATCH pattern] [COUNT count] hscan key cursor [MATCH pattern] [COUNT count] zscan key cursor [MATCH pattern] [COUNT count] 2. scan scan cursor [MATCH pattern] [COUNT count] [TYPE type]ï¼Œcursor è¡¨ç¤ºæ¸¸æ ‡ï¼ŒæŒ‡æŸ¥è¯¢å¼€å§‹çš„ä½ç½®ï¼Œcount é»˜è®¤ä¸º 10ï¼ŒæŸ¥è¯¢å®Œåä¼šè¿”å›ä¸‹ä¸€ä¸ªå¼€å§‹çš„æ¸¸æ ‡ï¼Œå½“è¿”å› 0 çš„æ—¶å€™è¡¨ç¤ºæ‰€æœ‰é”®æŸ¥è¯¢å®Œäº†\n127.0.0.1:6379[2]\u0026gt; scan 0 1) \u0026#34;3\u0026#34; 2) 1) \u0026#34;mystring\u0026#34; 2) \u0026#34;myzadd\u0026#34; 3) \u0026#34;myhset\u0026#34; 4) \u0026#34;mylist\u0026#34; 5) \u0026#34;myset2\u0026#34; 6) \u0026#34;myset1\u0026#34; 7) \u0026#34;mystring1\u0026#34; 8) \u0026#34;mystring3\u0026#34; 9) \u0026#34;mystring4\u0026#34; 10) \u0026#34;myset\u0026#34; 127.0.0.1:6379[2]\u0026gt; scan 3 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;myzadd1\u0026#34; 2) \u0026#34;mystring2\u0026#34; 3) \u0026#34;mylist2\u0026#34; 4) \u0026#34;myhset1\u0026#34; 5) \u0026#34;mylist1\u0026#34; MATCH å¯ä»¥é‡‡ç”¨æ¨¡ç³ŠåŒ¹é…æ‰¾å‡ºè‡ªå·±æƒ³è¦æŸ¥æ‰¾çš„é”®ï¼Œè¿™é‡Œçš„é€»è¾‘æ˜¯å…ˆæŸ¥å‡º 20 ä¸ªï¼Œå†åŒ¹é…ï¼Œè€Œä¸æ˜¯å…ˆåŒ¹é…å†æŸ¥è¯¢ï¼Œè¿™é‡ŒåŠ ä¸Š count 20 æ˜¯å› ä¸ºé»˜è®¤æŸ¥å‡ºçš„ 10 ä¸ªæ•°ä¸­å¯èƒ½ä¸èƒ½åŒ…å«æ‰€æœ‰çš„ç›¸å…³é¡¹ï¼Œæ‰€ä»¥æŠŠèŒƒå›´æ‰©å¤§åˆ°æŸ¥ 20 ä¸ªï¼Œæˆ‘è¿™é‡Œæµ‹è¯•çš„é”®æ€»å…±æœ‰ 15 ä¸ª\n127.0.0.1:6379[2]\u0026gt; scan 0 match mylist* count 20 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;mylist\u0026#34; 2) \u0026#34;mylist2\u0026#34; 3) \u0026#34;mylist1\u0026#34; TYPE å¯ä»¥æ ¹æ®å…·ä½“çš„ç»“æ„ç±»å‹æ¥åŒ¹é…è¯¥ç±»å‹çš„é”®\n127.0.0.1:6379[2]\u0026gt; scan 0 count 20 type list 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;mylist\u0026#34; 2) \u0026#34;mylist2\u0026#34; 3) \u0026#34;mylist1\u0026#34; 3. sscan sscan key cursor [MATCH pattern] [COUNT count]ï¼Œsscan çš„ç¬¬ä¸€ä¸ªå‚æ•°æ€»æ˜¯é›†åˆç±»å‹çš„ key\n127.0.0.1:6379[2]\u0026gt; sadd myset1 a b c d (integer) 4 127.0.0.1:6379[2]\u0026gt; smembers myset1 1) \u0026#34;d\u0026#34; 2) \u0026#34;a\u0026#34; 3) \u0026#34;c\u0026#34; 4) \u0026#34;b\u0026#34; 127.0.0.1:6379[2]\u0026gt; sscan myset1 0 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;d\u0026#34; 2) \u0026#34;c\u0026#34; 3) \u0026#34;b\u0026#34; 4) \u0026#34;a\u0026#34; 127.0.0.1:6379[2]\u0026gt; sscan myset1 0 match a 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;a\u0026#34; 4. hscan hscan key cursor [MATCH pattern] [COUNT count]ï¼Œsscan çš„ç¬¬ä¸€ä¸ªå‚æ•°æ€»æ˜¯å“ˆå¸Œç±»å‹çš„ key\n127.0.0.1:6379[2]\u0026gt; hset myhset1 kk1 vv1 kk2 vv2 kk3 vv3 (integer) 3 127.0.0.1:6379[2]\u0026gt; hgetall myhset1 1) \u0026#34;kk1\u0026#34; 2) \u0026#34;vv1\u0026#34; 3) \u0026#34;kk2\u0026#34; 4) \u0026#34;vv2\u0026#34; 5) \u0026#34;kk3\u0026#34; 6) \u0026#34;vv3\u0026#34; 127.0.0.1:6379[2]\u0026gt; hscan myhset1 0 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;kk1\u0026#34; 2) \u0026#34;vv1\u0026#34; 3) \u0026#34;kk2\u0026#34; 4) \u0026#34;vv2\u0026#34; 5) \u0026#34;kk3\u0026#34; 6) \u0026#34;vv3\u0026#34; 5. zscan zscan key cursor [MATCH pattern] [COUNT count]ï¼Œsscan çš„ç¬¬ä¸€ä¸ªå‚æ•°æ€»æ˜¯æœ‰åºé›†åˆç±»å‹çš„ key\n127.0.0.1:6379[2]\u0026gt; zadd myzadd1 1 zz1 2 zz2 3 zz3 (integer) 3 127.0.0.1:6379[2]\u0026gt; zrange myzadd1 0 -1 withscores 1) \u0026#34;zz1\u0026#34; 2) \u0026#34;1\u0026#34; 3) \u0026#34;zz2\u0026#34; 4) \u0026#34;2\u0026#34; 5) \u0026#34;zz3\u0026#34; 6) \u0026#34;3\u0026#34; 127.0.0.1:6379[2]\u0026gt; zscan myzadd1 0 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;zz1\u0026#34; 2) \u0026#34;1\u0026#34; 3) \u0026#34;zz2\u0026#34; 4) \u0026#34;2\u0026#34; 5) \u0026#34;zz3\u0026#34; 6) \u0026#34;3\u0026#34; ","permalink":"https://www.ziirui-resume-website.com/posts/tech/tech1/","summary":"1. ä»‹ç» scanå‘½ä»¤çš„ä½œç”¨å’Œkeys *çš„ä½œç”¨ç±»ä¼¼ï¼Œä¸»è¦ç”¨äºæŸ¥æ‰¾ redis ä¸­çš„é”®ï¼Œä½†æ˜¯åœ¨æ­£å¼çš„ç”Ÿäº§ç¯å¢ƒä¸­ä¸€èˆ¬ä¸ä¼šç›´æ¥ä½¿ç”¨keys *è¿™ä¸ªå‘½ä»¤ï¼Œå› ä¸ºä»–ä¼šè¿”å›æ‰€æœ‰çš„é”®ï¼Œå¦‚æœé”®çš„æ•°é‡å¾ˆå¤šä¼šå¯¼è‡´æŸ¥è¯¢æ—¶é—´å¾ˆé•¿ï¼Œè¿›è€Œå¯¼è‡´æœåŠ¡å™¨é˜»å¡ï¼Œæ‰€ä»¥éœ€è¦ scan æ¥è¿›è¡Œæ›´ç»†è‡´çš„æŸ¥æ‰¾ scanæ€»å…±æœ‰è¿™å‡ ç§å‘½ä»¤ï¼šscanã€sscan","title":"Redis scanå‘½ä»¤å­¦ä¹ "},{"content":"","permalink":"https://www.ziirui-resume-website.com/posts/life/life/","summary":"","title":"Life"},{"content":"\u0026lt;div\u0026gt; ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  \u0026lt;/div\u0026gt; ","permalink":"https://www.ziirui-resume-website.com/posts/tech/tech/","summary":"\u0026lt;div\u0026gt; ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£ç  ç§‘æŠ€ä»£","title":"Tech"},{"content":" Name: Zirui Zheng Base: New York Career: Engineer Love: Food, Music, Capybara Blog Source Source Code Blog principle My career, hustle, and life Site Inspiration Sulv\u0026#39;s Blog ä¸€ä¸ªè®°å½•æŠ€æœ¯ã€é˜…è¯»ã€ç”Ÿæ´»çš„åšå®¢ Kunyang\u0026#39;s Blog Kyrie Xie Yao\u0026#39;s World Hi, there. It\u0026#39;s Actually Yao ","permalink":"https://www.ziirui-resume-website.com/about/","summary":"Name: Zirui Zheng Base: New York Career: Engineer Love: Food, Music, Capybara Blog Source Source Code Blog principle My career, hustle, and life Site Inspiration Sulv\u0026#39;s Blog ä¸€ä¸ªè®°å½•æŠ€æœ¯ã€é˜…è¯»ã€ç”Ÿæ´»çš„åšå®¢ Kunyang\u0026#39;s Blog Kyrie Xie Yao\u0026#39;s World Hi, there. It\u0026#39;s Actually Yao","title":"ğŸ™‹ğŸ»â€â™‚ï¸About Me"}]